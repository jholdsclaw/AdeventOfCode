#include <iostream>
#include <sstream>
#include <algorithm>
#include <cassert>
#include "Day2.h"

namespace Day2 {
	void run() {
		std::cout << "Day 2:\n" << std::endl;

		std::string result;

		// Test Case 1 - result should be 1985
		Keypad1 keypad1;
		const std::string input1 = "ULL\nRRDDD\nLURDL\nUUUUD";
		result = parseInput(input1, &keypad1);
		std::cout << "Test 1: (ULL\\nRRDDD\\nLURDL\\nUUUUD) = Code: " << result << std::endl;
		assert(result == "1985");

		// Part 1 - result should be ??
		Keypad1 keypad2;
		const std::string input2 = "DUURRDRRURUUUDLRUDDLLLURULRRLDULDRDUULULLUUUDRDUDDURRULDRDDDUDDURLDLLDDRRURRUUUDDRUDDLLDDDURLRDDDULRDUDDRDRLRDUULDLDRDLUDDDLRDRLDLUUUDLRDLRUUUDDLUURRLLLUUUUDDLDRRDRDRLDRLUUDUDLDRUDDUDLLUUURUUDLULRDRULURURDLDLLDLLDUDLDRDULLDUDDURRDDLLRLLLLDLDRLDDUULRDRURUDRRRDDDUULRULDDLRLLLLRLLLLRLURRRLRLRDLULRRLDRULDRRLRURDDLDDRLRDLDRLULLRRUDUURRULLLRLRLRRUDLRDDLLRRUDUDUURRRDRDLDRUDLDRDLUUULDLRLLDRULRULLRLRDRRLRLULLRURUULRLLRRRDRLULUDDUUULDULDUDDDUDLRLLRDRDLUDLRLRRDDDURUUUDULDLDDLDRDDDLURLDRLDURUDRURDDDDDDULLDLDLU\nLURLRUURDDLDDDLDDLULRLUUUDRDUUDDUDLDLDDLLUDURDRDRULULLRLDDUDRRDRUDLRLDDDURDUURLUURRLLDRURDRLDURUDLRLLDDLLRDRRLURLRRUULLLDRLULURULRRDLLLDLDLRDRRURUUUDUDRUULDLUDLURLRDRRLDRUDRUDURLDLDDRUULDURDUURLLUDRUUUUUURRLRULUDRDUDRLLDUDUDUULURUURURULLUUURDRLDDRLUURDLRULDRRRRLRULRDLURRUULURDRRLDLRUURUDRRRDRURRLDDURLUDLDRRLDRLLLLRDUDLULUDRLLLDULUDUULLULLRLURURURDRRDRUURDULRDDLRULLLLLLDLLURLRLLRDLLRLUDLRUDDRLLLDDUDRLDLRLDUDU\nRRDDLDLRRUULRDLLURLRURDLUURLLLUUDDULLDRURDUDRLRDRDDUUUULDLUDDLRDULDDRDDDDDLRRDDDRUULDLUDUDRRLUUDDRUDLUUDUDLUDURDURDLLLLDUUUUURUUURDURUUUUDDURULLDDLDLDLULUDRULULULLLDRLRRLLDLURULRDLULRLDRRLDDLULDDRDDRURLDLUULULRDRDRDRRLLLURLLDUUUDRRUUURDLLLRUUDDDULRDRRUUDDUUUDLRRURUDDLUDDDUDLRUDRRDLLLURRRURDRLLULDUULLURRULDLURRUURURRLRDULRLULUDUULRRULLLDDDDURLRRRDUDULLRRDURUURUUULUDLDULLUURDRDRRDURDLUDLULRULRLLURULDRUURRRRDUDULLLLLRRLRUDDUDLLURLRDDLLDLLLDDUDDDDRDURRL\nLLRURUDUULRURRUDURRDLUUUDDDDURUUDLLDLRULRUUDUURRLRRUDLLUDLDURURRDDLLRUDDUDLDUUDDLUUULUUURRURDDLUDDLULRRRUURLDLURDULULRULRLDUDLLLLDLLLLRLDLRLDLUULLDDLDRRRURDDRRDURUURLRLRDUDLLURRLDUULDRURDRRURDDDDUUUDDRDLLDDUDURDLUUDRLRDUDLLDDDDDRRDRDUULDDLLDLRUDULLRRLLDUDRRLRURRRRLRDUDDRRDDUUUDLULLRRRDDRUUUDUUURUULUDURUDLDRDRLDLRLLRLRDRDRULRURLDDULRURLRLDUURLDDLUDRLRUDDURLUDLLULDLDDULDUDDDUDRLRDRUUURDUULLDULUUULLLDLRULDULUDLRRURDLULUDUDLDDRDRUUULDLRURLRUURDLULUDLULLRD\nUURUDRRDDLRRRLULLDDDRRLDUDLRRULUUDULLDUDURRDLDRRRDLRDUUUDRDRRLLDULRLUDUUULRULULRUDURDRDDLDRULULULLDURULDRUDDDURLLDUDUUUULRUULURDDDUUUURDLDUUURUDDLDRDLLUDDDDULRDLRUDRLRUDDURDLDRLLLLRLULRDDUDLLDRURDDUDRRLRRDLDDUDRRLDLUURLRLLRRRDRLRLLLLLLURULUURRDDRRLRLRUURDLULRUUDRRRLRLRULLLLUDRULLRDDRDDLDLDRRRURLURDDURRLUDDULRRDULRURRRURLUURDDDUDLDUURRRLUDUULULURLRDDRULDLRLLUULRLLRLUUURUUDUURULRRRUULUULRULDDURLDRRULLRDURRDDDLLUDLDRRRRUULDDD";
		result = parseInput(input2, &keypad2);
		std::cout << "Part 1 result: " << result << std::endl;

		// Test Case 2 - result should be 5DB3
		Keypad2 keypad3;
		const std::string input3 = "ULL\nRRDDD\nLURDL\nUUUUD";
		result = parseInput(input3, &keypad3);
		std::cout << "Test 2: (ULL\\nRRDDD\\nLURDL\\nUUUUD) = Code: " << result << std::endl;
		assert(result == "5DB3");

		// Part 2 - result should be ??
		Keypad2 keypad4;
		const std::string input4 = "DUURRDRRURUUUDLRUDDLLLURULRRLDULDRDUULULLUUUDRDUDDURRULDRDDDUDDURLDLLDDRRURRUUUDDRUDDLLDDDURLRDDDULRDUDDRDRLRDUULDLDRDLUDDDLRDRLDLUUUDLRDLRUUUDDLUURRLLLUUUUDDLDRRDRDRLDRLUUDUDLDRUDDUDLLUUURUUDLULRDRULURURDLDLLDLLDUDLDRDULLDUDDURRDDLLRLLLLDLDRLDDUULRDRURUDRRRDDDUULRULDDLRLLLLRLLLLRLURRRLRLRDLULRRLDRULDRRLRURDDLDDRLRDLDRLULLRRUDUURRULLLRLRLRRUDLRDDLLRRUDUDUURRRDRDLDRUDLDRDLUUULDLRLLDRULRULLRLRDRRLRLULLRURUULRLLRRRDRLULUDDUUULDULDUDDDUDLRLLRDRDLUDLRLRRDDDURUUUDULDLDDLDRDDDLURLDRLDURUDRURDDDDDDULLDLDLU\nLURLRUURDDLDDDLDDLULRLUUUDRDUUDDUDLDLDDLLUDURDRDRULULLRLDDUDRRDRUDLRLDDDURDUURLUURRLLDRURDRLDURUDLRLLDDLLRDRRLURLRRUULLLDRLULURULRRDLLLDLDLRDRRURUUUDUDRUULDLUDLURLRDRRLDRUDRUDURLDLDDRUULDURDUURLLUDRUUUUUURRLRULUDRDUDRLLDUDUDUULURUURURULLUUURDRLDDRLUURDLRULDRRRRLRULRDLURRUULURDRRLDLRUURUDRRRDRURRLDDURLUDLDRRLDRLLLLRDUDLULUDRLLLDULUDUULLULLRLURURURDRRDRUURDULRDDLRULLLLLLDLLURLRLLRDLLRLUDLRUDDRLLLDDUDRLDLRLDUDU\nRRDDLDLRRUULRDLLURLRURDLUURLLLUUDDULLDRURDUDRLRDRDDUUUULDLUDDLRDULDDRDDDDDLRRDDDRUULDLUDUDRRLUUDDRUDLUUDUDLUDURDURDLLLLDUUUUURUUURDURUUUUDDURULLDDLDLDLULUDRULULULLLDRLRRLLDLURULRDLULRLDRRLDDLULDDRDDRURLDLUULULRDRDRDRRLLLURLLDUUUDRRUUURDLLLRUUDDDULRDRRUUDDUUUDLRRURUDDLUDDDUDLRUDRRDLLLURRRURDRLLULDUULLURRULDLURRUURURRLRDULRLULUDUULRRULLLDDDDURLRRRDUDULLRRDURUURUUULUDLDULLUURDRDRRDURDLUDLULRULRLLURULDRUURRRRDUDULLLLLRRLRUDDUDLLURLRDDLLDLLLDDUDDDDRDURRL\nLLRURUDUULRURRUDURRDLUUUDDDDURUUDLLDLRULRUUDUURRLRRUDLLUDLDURURRDDLLRUDDUDLDUUDDLUUULUUURRURDDLUDDLULRRRUURLDLURDULULRULRLDUDLLLLDLLLLRLDLRLDLUULLDDLDRRRURDDRRDURUURLRLRDUDLLURRLDUULDRURDRRURDDDDUUUDDRDLLDDUDURDLUUDRLRDUDLLDDDDDRRDRDUULDDLLDLRUDULLRRLLDUDRRLRURRRRLRDUDDRRDDUUUDLULLRRRDDRUUUDUUURUULUDURUDLDRDRLDLRLLRLRDRDRULRURLDDULRURLRLDUURLDDLUDRLRUDDURLUDLLULDLDDULDUDDDUDRLRDRUUURDUULLDULUUULLLDLRULDULUDLRRURDLULUDUDLDDRDRUUULDLRURLRUURDLULUDLULLRD\nUURUDRRDDLRRRLULLDDDRRLDUDLRRULUUDULLDUDURRDLDRRRDLRDUUUDRDRRLLDULRLUDUUULRULULRUDURDRDDLDRULULULLDURULDRUDDDURLLDUDUUUULRUULURDDDUUUURDLDUUURUDDLDRDLLUDDDDULRDLRUDRLRUDDURDLDRLLLLRLULRDDUDLLDRURDDUDRRLRRDLDDUDRRLDLUURLRLLRRRDRLRLLLLLLURULUURRDDRRLRLRUURDLULRUUDRRRLRLRULLLLUDRULLRDDRDDLDLDRRRURLURDDURRLUDDULRRDULRURRRURLUURDDDUDLDUURRRLUDUULULURLRDDRULDLRLLUULRLLRLUUURUUDUURULRRRUULUULRULDDURLDRRULLRDURRDDDLLUDLDRRRRUULDDD";
		result = parseInput(input4, &keypad4);
		std::cout << "Part 2 result: " << result << std::endl;

		return;
	}

	std::string parseInput(std::string const &input, Keypad *kpd) {
		// string to store our result code
		std::string code;

		// create a string stream to parse through our input
		std::stringstream ss(input);

		while (ss.good()) {
			// per spec, each line is one key press command queue
			std::string line;

			// get first line
			std::getline(ss, line);
			code += kpd->processInput(line); // quick hack to convert single digit to char
		}

		return code;
	}

	char Keypad::processInput(std::string const &input) {
		// create a string stream to parse through our input
		std::stringstream ss(input);
		char c;

		while (ss >> c) {
			switch (c) {
			case 'U':
			case 'u':
				currentKeypadNumber = currentKeypadNumber->up;
				break;
			case 'D':
			case 'd':
				currentKeypadNumber = currentKeypadNumber->down;
				break;
			case 'L':
			case 'l':
				currentKeypadNumber = currentKeypadNumber->left;
				break;
			case 'R':
			case 'r':
				currentKeypadNumber = currentKeypadNumber->right;
				break;
			default:
				throw std::runtime_error("Bad input string");
				break;
			}
		}

		return currentKeypadNumber->key;
	}

	Keypad1::Keypad1() noexcept {
		keys = new KeypadNumber[9];

		char key = '1';

		// Loop through and setup our relative positions, capped at the bounds of the keypad per the spec
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 3; j++) {
				keys[(3 * i) + j].up = &keys[(3 * std::max(0, i - 1)) + j];
				keys[(3 * i) + j].down = &keys[(3 * std::min(2, i + 1)) + j];
				keys[(3 * i) + j].left = &keys[(3 * i) + std::max(0, j - 1)];
				keys[(3 * i) + j].right = &keys[(3 * i) + std::min(2, j + 1)];
				keys[(3 * i) + j].key = key++;
			}
		}
		// Per spec, always start at number 5
		currentKeypadNumber = &keys[4];
	}

	Keypad1::~Keypad1() noexcept {
		delete[] keys;
	}

	Keypad2::Keypad2() noexcept {
		keys = new KeypadNumber[13];

		// Can't think of a clever way to build this keypad, so going brute force method
		keys[0].up = &keys[0];
		keys[0].down = &keys[2];
		keys[0].left = &keys[0];
		keys[0].right = &keys[0];
		keys[0].key = '1';

		keys[1].up = &keys[1];
		keys[1].down = &keys[5];
		keys[1].left = &keys[1];
		keys[1].right = &keys[2];
		keys[1].key = '2';

		keys[2].up = &keys[0];
		keys[2].down = &keys[6];
		keys[2].left = &keys[1];
		keys[2].right = &keys[3];
		keys[2].key = '3';

		keys[3].up = &keys[3];
		keys[3].down = &keys[7];
		keys[3].left = &keys[2];
		keys[3].right = &keys[3];
		keys[3].key = '4';

		keys[4].up = &keys[4];
		keys[4].down = &keys[4];
		keys[4].left = &keys[4];
		keys[4].right = &keys[5];
		keys[4].key = '5';

		keys[5].up = &keys[1];
		keys[5].down = &keys[9];
		keys[5].left = &keys[4];
		keys[5].right = &keys[6];
		keys[5].key = '6';

		keys[6].up = &keys[2];
		keys[6].down = &keys[10];
		keys[6].left = &keys[5];
		keys[6].right = &keys[7];
		keys[6].key = '7';

		keys[7].up = &keys[3];
		keys[7].down = &keys[11];
		keys[7].left = &keys[6];
		keys[7].right = &keys[8];
		keys[7].key = '8';

		keys[8].up = &keys[8];
		keys[8].down = &keys[8];
		keys[8].left = &keys[7];
		keys[8].right = &keys[8];
		keys[8].key = '9';

		keys[9].up = &keys[5];
		keys[9].down = &keys[9];
		keys[9].left = &keys[9];
		keys[9].right = &keys[10];
		keys[9].key = 'A';

		keys[10].up = &keys[6];
		keys[10].down = &keys[12];
		keys[10].left = &keys[9];
		keys[10].right = &keys[11];
		keys[10].key = 'B';

		keys[11].up = &keys[11];
		keys[11].down = &keys[11];
		keys[11].left = &keys[10];
		keys[11].right = &keys[11];
		keys[11].key = 'C';

		keys[12].up = &keys[10];
		keys[12].down = &keys[12];
		keys[12].left = &keys[12];
		keys[12].right = &keys[12];
		keys[12].key = 'D';

		// Per spec, always start at number 5
		currentKeypadNumber = &keys[4];
	}

	Keypad2::~Keypad2() noexcept {
		delete[] keys;
	}

}
